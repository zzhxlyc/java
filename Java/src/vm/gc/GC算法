引用计数
优点：	1：将GC的工作平摊到每个引用计数改变的操作上，真正GC的时候工作量少
		2：简单
缺点：	1：对引用环（只有A有B的引用，只有B有A的引用）的回收
		2：对每个变量保存并维持有一个引用计数字段，增加时间空间复杂度
		
标记清除	有一个某些对象的根集合，通过这些根集合可以达到的路径的对象都不被回收（每个对象带有一个live的flag）
	GC Roots	栈中对象、方法区静态Field的对象、常量对象、JNI（Native方法）中引用的对象
优点：	1：也简单
缺点：	1：非实时，GC线程不可抢占，否则造成错误
		2：GC时工作量较大
		
标记复制	利用标记清楚法找到live对象和垃圾对象，将live对象全部重新copy到新的内存区域，原区域全部清除
		为新生代所使用的GC策略
优点：	1：每一次GC都可以顺带做一次内存碎片整理，没有额外开销
		2：比标记清除成为抢占式要容易一些
缺点：	1：额外内存开销，一半的内存是不能使用的
			可由IBM的研究（98%的对象很快死掉这一理论）来优化, 新生代内存分为Eden区域和Survivor区域
			1份Eden区域, 2份Survivor区域用来复制算法, HotSpotVM中Eden:Survivor = 8:1
		2：对于大对象的复制操作麻烦，不如标记清除方便（大对象建议直接开辟内存到老年代）
		3：不适合代码区这样对象存活率高的内存区域
		
标记整理	标记清除后, 将活着的对象在原内存上分散的地方整理到一起，减少内存碎片
		为老年代所使用的GC策略

分代收集算法	按新生代与老年代将内存分块, 综合标记复制和标记整理来针对对象存活率高和低的不同内存区域
		

递增式垃圾收集器：可被抢占的GC线程，适合于实时系统