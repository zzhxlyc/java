每一个线程有自己一块工作内存区，其中会存放着被所有线程共享的主内存中的变量的值的拷贝，然后在线程执行
过程中，在自己的工作内存中操作这些变量，线程结束时再将这些变量值写回共享内存。

因为线程有自己的工作内存区，拷贝了主存值后不经常去重新获取主存的值，这样对其他线程对这个值的修改就短时间
内不可见。
JVM -client模式（会发现变量的修改，但是不是即时） -server模式（对代码进行优化，不会发现变量的修改）
使用volatile关键字
1.其他线程对变量的修改，可以即时反应在当前线程中
2.确保当前线程对变量的修改，能即时写回共享主内存中，并被其他线程可见
3.使用volatile声明的变量，编译器会保证其有序性

线程从主存中读取数据或者写数据行为包含几个原子操作（read + load, store + write）, 所以在原子操作之间
可能存在被插入的情况。

在32位系统中，对除了long和double这64位的类型，其他数据类型保证写入是原子性的（即便不能保证
是which线程写入的结果，但肯定是某一个线程的值）, 但是long和double会将它们的64位数据分成2次32位
的操作来执行，这就导致写入操作不是原子的，会导致最终写入主存的值可能不是任何一个线程的结果
（A线程前32位+B线程后32位）